import type { Markdown } from '@vuepress/markdown';
import type { App } from '../app';
import type { Page } from '../page';
declare type PromiseOrNot<T> = Promise<T> | T;
export declare type Hook<Exposed, Normalized = Exposed, Result = Normalized extends (...args: any) => infer U ? U extends Promise<infer V> ? V : U : void> = {
    exposed: Exposed;
    normalized: Normalized;
    result: Result;
};
export declare type LifeCycleHook = Hook<(app: App) => PromiseOrNot<void>>;
export declare type ClientFilesHook = Hook<string | string[] | ((app: App) => PromiseOrNot<string | string[]>), (app: App) => Promise<string[]>>;
export declare type ReturnObjectHook = Hook<Record<string, string> | (() => Record<string, string>), () => Record<string, string>>;
export declare type ExtendsMarkdownHook = Hook<(md: Markdown) => void>;
export declare type ExtendsPageDataHook = Hook<(page: Page) => PromiseOrNot<Record<string, unknown>>>;
/**
 * List of hooks
 */
export interface Hooks {
    onInitialized: LifeCycleHook;
    onPrepared: LifeCycleHook;
    onUpdated: LifeCycleHook;
    onGenerated: LifeCycleHook;
    extendsMarkdown: ExtendsMarkdownHook;
    extendsPageData: ExtendsPageDataHook;
    clientAppEnhanceFiles: ClientFilesHook;
    clientAppRootComponentFiles: ClientFilesHook;
    clientAppSetupFiles: ClientFilesHook;
    alias: ReturnObjectHook;
    define: ReturnObjectHook;
}
/**
 * Name of hooks
 */
export declare type HooksName = keyof Hooks;
/**
 * Exposed hooks API that can be accessed by a plugin
 */
export declare type HooksExposed = {
    [K in HooksName]: Hooks[K]['exposed'];
};
/**
 * Normalized hooks
 */
export declare type HooksNormalized = {
    [K in HooksName]: Hooks[K]['normalized'];
};
/**
 * Result of hooks
 */
export declare type HooksResult = {
    [K in HooksName]: Hooks[K]['result'];
};
/**
 * Hook item
 */
export interface HookItem<T extends HooksName> {
    pluginName: string;
    hook: HooksNormalized[T];
}
/**
 * Hook items queue
 */
export interface HookQueue<T extends HooksName> {
    name: T;
    items: HookItem<T>[];
    add: (item: HookItem<T>) => void;
    process: (...args: Parameters<HooksNormalized[T]>) => Promise<HooksResult[T][]>;
    processSync: (...args: Parameters<HooksNormalized[T]>) => HooksResult[T][];
}
export {};
//# sourceMappingURL=hooks.d.ts.map