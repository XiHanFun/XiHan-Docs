"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.codePlugin = void 0;
const highlightLines_1 = require("./highlightLines");
const resolveLanguage_1 = require("./resolveLanguage");
/**
 * Code plugin
 */
const codePlugin = (md, { highlight = true, highlightLines = true, lineNumbers = true, preWrapper = true, vPre = true, } = {}) => {
    // lazy-load highlight
    let createCodeHighlighter;
    if (highlight) {
        createCodeHighlighter = require('./codeHighlighter').createCodeHighlighter;
    }
    // override default fence renderer
    md.renderer.rules.fence = (tokens, idx, options, env, slf) => {
        var _a;
        const token = tokens[idx];
        // get token info
        const info = token.info ? md.utils.unescapeAll(token.info).trim() : '';
        // resolve highlight line ranges
        let highlightLinesRanges = null;
        if (highlightLines) {
            highlightLinesRanges = highlightLines_1.resolveHighlightLinesRanges(info);
        }
        // get user-defined language alias from the token info
        const langAlias = ((_a = info.match(/^([a-zA-Z]+)/)) === null || _a === void 0 ? void 0 : _a[1]) || 'text';
        // try to resolve language according to the alias
        const language = resolveLanguage_1.resolveLanguage(langAlias);
        // the result of code and lang
        let code = token.content;
        // try to highlight code
        if (createCodeHighlighter) {
            const codeHighlighter = createCodeHighlighter(language.name);
            if (codeHighlighter !== null) {
                code = codeHighlighter(code);
            }
        }
        // if the code is not highlighted, treat it as text and escape it
        if (code === token.content) {
            code = md.utils.escapeHtml(code);
        }
        const languageClass = `${options.langPrefix}${language.name}`;
        let result = `<pre${vPre ? ' v-pre' : ''} class="${languageClass}"><code>${code}</code></pre>`;
        // if `preWrapper` is disabled, return directly
        if (!preWrapper) {
            return result;
        }
        // code fences always have an ending `\n`, so we should trim the last line
        const lines = code.split('\n').slice(0, -1);
        // generate highlight lines
        if (highlightLinesRanges) {
            const ranges = highlightLinesRanges;
            const highlightLinesCode = lines
                .map((_, index) => {
                if (highlightLines_1.isInHighlightLinesRanges(index + 1, ranges)) {
                    return '<div class="highlight-line">&nbsp;</div>';
                }
                return '<br>';
            })
                .join('');
            result = `${result}<div class="highlight-lines">${highlightLinesCode}</div>`;
        }
        // generate line numbers
        if (lineNumbers) {
            // generate line numbers code
            const lineNumbersCode = lines
                .map((_, index) => `<span class="line-number">${index + 1}</span><br>`)
                .join('');
            result = `${result}<div class="line-numbers">${lineNumbersCode}</div>`;
        }
        result = `<div class="${languageClass} ext-${language.ext}${lineNumbers ? ' line-numbers-mode' : ''}">${result}</div>`;
        return result;
    };
};
exports.codePlugin = codePlugin;
//# sourceMappingURL=codePlugin.js.map